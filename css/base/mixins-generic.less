// =====================================================================
// Set an element to be constrained to every breakpoint's maximum width.
// =====================================================================

.frame(@margin: 0px) {
	@gutter: @margin * 2;
	width: @desktop-small-min - @gutter;
	margin: auto;

	@media only screen and (min-width: @desktop-large-min) {
		width: @desktop-large-min - @gutter;
	}

	@media only screen and (max-width: @tablet-max) and (min-width: @tablet-min) {
		width: @tablet-min - @gutter;
	}

	@media only screen and (max-width: @mobile-large-max) {
		.mobile-full();
	}
}


// ======================================================
// REstore previously `.frame()`d elements to 100% width.
// ======================================================

.frame-cancel() {
	.clearer-cancel();
	width: 100%;
	margin: 0px;

	// FIXME: Do I need media queries here? I had them on eVersity, but I don't think I had to?
}

// ===============================================
// .frame()â€™s mobile rules for manual application.
// ===============================================

.mobile-full() {
	width: 90%;
	margin-left: 5%;
	margin-right: 5%;
}


// =============================================================================================
// Assigns an element to the same number of grid columns in each breakpoint (except for mobile,
// where everything is full width). It uses the `.cols-width()` mixin below, which can be called
// manually if an element should be a different number of columns in different breakpoints.
// =============================================================================================

.cols(@num, @float: left) {

	.cols-width(@num, @desktop-small-column-x, @float);

	@media only screen and (min-width: @desktop-large-min) {
		.cols-width(@num, @desktop-large-column-x, @float);
	}

	@media only screen and (max-width: @tablet-max) and (min-width: @tablet-min) {
		.cols-width(@num, @tablet-column-x, @float);
	}

	@media only screen and (max-width: @mobile-large-max) {
		width: auto;
		margin-left: auto;
		margin-right: auto;
		float: none;
	}
}


// ============================================================================================
// The 'inner' parameter is for when you're already inside an element that's been used with
// `.cols()`, or otherwise has the 10px horizontal margins applied. It removes margins from the
// first and last elements, keeping the total width correct.
// ============================================================================================

.cols(inner, @num, @float: left) {
	.cols(@num, @float);

	&:first-child {
		margin-left: 0px;
	}

	&:last-child {
		margin-right: 0px;
	}
}


// ===============================================================================================
// Used by `.cols()` to calculate the widths for each breakpoint. The `@full-col` parameter is the
// width of a full column before margins are subtracted, and by default it uses the column widths
// derived in `sizes.less`.
// ===============================================================================================

.cols-width(@num, @full-col, @float: left, @margin: 10px,) {
	@gutter: @margin * 2;
	@col-width: @full-col - @gutter;

	margin-left: @margin;
	margin-right: @margin;
	width: @num * @full-col - @gutter;
}


// ================================================================================================
// Dark magic that takes a container of items and puts them side-by-side, evenly distributed across
// the container's width, no matter how many elements there are.
// ================================================================================================

.distribute-center(@overflow: hidden, @offset-v: 1px) {
	text-align: justify;
	overflow: @overflow;

	&:after {
		content: '';
		display: inline-block;
		width: 100%;
	}

	&:before {
		content: '';
		display: block;
		margin-top: -@offset-v + 1px;
	}

	> * {
		display: inline-block;
		margin-right: -0.25em;
	//	position: relative;
		margin-top: @offset-v - 2px;
	}
}


// ==============================================================================================
// Gives you a sticky footer when you put it on the html element and set the `@footer-y` variable
// correctly in `sizes.less`. But heed the warning on `.clearer()` below.
//
// Source: http://ryanfait.com/resources/footer-stick-to-bottom-of-page/
// ==============================================================================================

.sticky-footer(@footer-y: @footer-y) {
	&, body {
		height: 100%;
	}

	#page-wrapper {
		min-height: 100%;
		height: auto !important;
		height: 100%;
		margin: 0 auto -@footer-y;
	}

	footer, #push {
		height: @footer-y;
	}

	body.admin-menu {
		margin-top: 0px !important;
		padding-top: @admin-menu-y;
	}

	@media only screen and (max-width: @tablet-max) {
		.sticky-footer-cancel();
	}
}


// =====================================
// Does exactly what it says on the tin.
// =====================================

.sticky-footer-cancel() {
	&, body {
		height: auto;
	}

	#page-wrapper {
		min-height: 0px;
		height: auto !important;
		margin: 0 auto;
	}

	footer, #push {
		height: auto;
	}

	body.admin-menu {
		padding-top: 29px;
	}
}


// =============================================================================================
// Can be applied to any element to make floats behave. Should also be your first suspect if you
// have a problem getting your sticky footer to stick.
// =============================================================================================

.clearer() {
	&:after {
		content: ".";
		display: block;
		font-size: 0.1px;
		line-height: 0px;
		height: 0px;
		clear: both;
		visibility: hidden;
	}
}


// =================
// Self-explanatory.
// =================

.clearer-cancel() {
	&:after {
		content: none;
	}
}


// =======================================================
// Can be applied to `<ul>`s and `<ol>`s to regain sanity.
// =======================================================

.list-reset() {
	display: block;
	margin: 0px;
	padding: 0px;
	text-indent: 0px;
	list-style: none;
	list-style-type: none;
	list-style-image: none;
}


// ======================
// For image replacement.
// ======================

.hide-text() {
	font-size: 0.1px;
	text-indent: 100%;
	white-space: nowrap;
	overflow: hidden;
	display: block;
}


// ==============================================
// Centered floats! What will they think of next?
// ==============================================

.centered-menu(@overflow: hidden) {
	width: 100%;
	overflow: @overflow; // Needs to be visible sometimes, as with dropdowns

	> ul {
		position: relative;
		float: right;
		right: 50%;

		> li {
			position: relative;
			float: left;
			left: 50%;
		}
	}
}


// =================================================================================================
// The next three use absolute positioning and CSS transforms to absolutely center objects on one or
// both axes. Should be used as a last resort.
// =================================================================================================

.vertical-center() {
	position: absolute;
	top: 50%;
	transform: translateY(-50%);
}

.horizontal-center() {
	position: absolute;
	left: 50%;
	transform: translateX(-50%);
}

.all-center() {
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
}